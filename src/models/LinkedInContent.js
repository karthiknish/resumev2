import mongoose from "mongoose";

/**
 * LinkedIn Content Model
 * Stores LinkedIn posts and carousels generated by users
 * Supports content history persistence for the admin dashboard
 */

const LinkedInContentSchema = new mongoose.Schema(
  {
    // Reference to the user who generated the content
    author: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    // Content type: post or carousel
    contentType: {
      type: String,
      enum: ["post", "carousel"],
      required: [true, "Content type is required"],
    },

    // Original topic/idea provided by the user
    topic: {
      type: String,
      required: [true, "Topic is required"],
      maxlength: [500, "Topic cannot be more than 500 characters"],
    },

    // === POST FIELDS ===
    // Generated post content (for contentType: "post")
    postContent: {
      type: String,
      required: function () {
        return this.contentType === "post";
      },
    },

    // Post type (insight, story, tutorial, opinion, celebration)
    postType: {
      type: String,
      enum: ["insight", "story", "tutorial", "opinion", "celebration"],
    },

    // Post tone (professional, casual, thoughtful, inspiring, educational)
    tone: {
      type: String,
      enum: ["professional", "casual", "thoughtful", "inspiring", "educational"],
    },

    // Post length (short, medium, long)
    length: {
      type: String,
      enum: ["short", "medium", "long"],
    },

    // Hashtags used in the post
    hashtags: [
      {
        type: String,
        trim: true,
      },
    ],

    // === CAROUSEL FIELDS ===
    // Slide content array (for contentType: "carousel")
    slides: [
      {
        slideNumber: { type: Number, required: true },
        heading: { type: String, required: true },
        body: { type: String, required: true },
        hasNumber: { type: Boolean, default: false },
      },
    ],

    // Generated slide images stored as base64 or URLs
    slideImages: [
      {
        slideNumber: { type: Number, required: true },
        imageData: { type: String }, // Base64 encoded image or URL
        mimeType: { type: String, default: "image/png" },
        error: { type: String }, // Error message if generation failed
      },
    ],

    // Carousel style preferences
    carouselStyle: {
      type: String,
      enum: ["dark_pro", "light_pro", "gradient"],
    },

    // Carousel aspect ratio
    aspectRatio: {
      type: String,
      enum: ["portrait", "square"],
    },

    // === COMMON FIELDS ===
    // Generation status
    status: {
      type: String,
      enum: ["draft", "generated", "failed"],
      default: "generated",
    },

    // Error message if generation failed
    errorMessage: {
      type: String,
    },

    // AI model used for generation
    model: {
      type: String,
      default: "gemini-2.5-flash",
    },

    // Template used (if any)
    templateUsed: {
      category: { type: String }, // hook, story, cta for posts; educational, professional, engaging for carousels
      templateId: { type: String },
    },

    // Character/word count metrics
    metrics: {
      characterCount: { type: Number },
      wordCount: { type: Number },
      slideCount: { type: Number },
    },

    // Whether content has been copied/downloaded
    isExported: {
      type: Boolean,
      default: false,
    },

    // Export type (copy, pdf, images)
    exportType: {
      type: String,
      enum: ["copy", "pdf", "images", "none"],
      default: "none",
    },

    // Export timestamp
    exportedAt: {
      type: Date,
    },

    // Notes or tags for organizing content
    notes: {
      type: String,
      maxlength: [1000, "Notes cannot be more than 1000 characters"],
    },

    // User-defined tags for categorization
    tags: [
      {
        type: String,
        trim: true,
      },
    ],

    // Flag to mark favorite content
    isFavorite: {
      type: Boolean,
      default: false,
    },

    // Soft delete flag
    isDeleted: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true }
);

// === INDEXES ===

// Index for querying by user and content type (common query pattern)
LinkedInContentSchema.index({ author: 1, contentType: 1, createdAt: -1 });

// Index for querying by content type and creation date
LinkedInContentSchema.index({ contentType: 1, createdAt: -1 });

// Index for querying favorites
LinkedInContentSchema.index({ author: 1, isFavorite: 1, createdAt: -1 });

// Index for querying non-deleted content
LinkedInContentSchema.index({ isDeleted: 1, createdAt: -1 });

// Index for querying by status
LinkedInContentSchema.index({ status: 1, createdAt: -1 });

// Index for querying by tags
LinkedInContentSchema.index({ tags: 1 });

// Text search index for topic and post content
LinkedInContentSchema.index(
  { topic: "text", postContent: "text", notes: "text" },
  { name: "LinkedInContentTextIndex", weights: { topic: 10, postContent: 5, notes: 3 } }
);

// Compound index for filtering by user, deleted status, and date
LinkedInContentSchema.index({ author: 1, isDeleted: 1, createdAt: -1 });

// === VIRTUALS ===

// Virtual for checking if this is a post
LinkedInContentSchema.virtual("isPost").get(function () {
  return this.contentType === "post";
});

// Virtual for checking if this is a carousel
LinkedInContentSchema.virtual("isCarousel").get(function () {
  return this.contentType === "carousel";
});

// Virtual for slide count (computed from slideImages array)
LinkedInContentSchema.virtual("totalSlides").get(function () {
  return this.slideImages?.length || 0;
});

// Ensure virtuals are included in JSON
LinkedInContentSchema.set("toJSON", { virtuals: true });
LinkedInContentSchema.set("toObject", { virtuals: true });

// === METHODS ===

/**
 * Mark content as exported
 * @param {string} exportType - Type of export (copy, pdf, images)
 */
LinkedInContentSchema.methods.markAsExported = function (exportType) {
  this.isExported = true;
  this.exportType = exportType;
  this.exportedAt = new Date();
  return this.save();
};

/**
 * Soft delete content
 */
LinkedInContentSchema.methods.softDelete = function () {
  this.isDeleted = true;
  return this.save();
};

/**
 * Restore soft deleted content
 */
LinkedInContentSchema.methods.restore = function () {
  this.isDeleted = false;
  return this.save();
};

/**
 * Toggle favorite status
 */
LinkedInContentSchema.methods.toggleFavorite = function () {
  this.isFavorite = !this.isFavorite;
  return this.save();
};

// === STATIC METHODS ===

/**
 * Find all content for a user (excluding soft deleted)
 * @param {string} userId - User ID
 * @param {object} options - Query options (contentType, limit, skip, sort)
 */
LinkedInContentSchema.statics.findByUser = function (userId, options = {}) {
  const {
    contentType,
    limit = 50,
    skip = 0,
    sort = { createdAt: -1 },
    includeDeleted = false,
  } = options;

  const query = {
    author: userId,
  };

  if (!includeDeleted) {
    query.isDeleted = false;
  }

  if (contentType) {
    query.contentType = contentType;
  }

  return this.find(query).sort(sort).limit(limit).skip(skip).populate("author", "name email");
};

/**
 * Find favorite content for a user
 * @param {string} userId - User ID
 */
LinkedInContentSchema.statics.findFavorites = function (userId) {
  return this.find({
    author: userId,
    isFavorite: true,
    isDeleted: false,
  }).sort({ createdAt: -1 });
};

/**
 * Search content by text
 * @param {string} userId - User ID
 * @param {string} searchTerm - Search term
 */
LinkedInContentSchema.statics.searchContent = function (userId, searchTerm) {
  return this.find(
    {
      author: userId,
      isDeleted: false,
      $text: { $search: searchTerm },
    },
    { score: { $meta: "textScore" } }
  )
    .sort({ score: { $meta: "textScore" } })
    .populate("author", "name email");
};

/**
 * Get statistics for a user
 * @param {string} userId - User ID
 */
LinkedInContentSchema.statics.getUserStats = async function (userId) {
  const stats = await this.aggregate([
    {
      $match: { author: userId, isDeleted: false },
    },
    {
      $group: {
        _id: "$contentType",
        count: { $sum: 1 },
        exported: { $sum: { $cond: ["$isExported", 1, 0] } },
        favorites: { $sum: { $cond: ["$isFavorite", 1, 0] } },
      },
    },
  ]);

  const result = {
    total: 0,
    posts: 0,
    carousels: 0,
    exported: 0,
    favorites: 0,
  };

  stats.forEach((stat) => {
    result.total += stat.count;
    result.exported += stat.exported;
    result.favorites += stat.favorites;
    if (stat._id === "post") result.posts = stat.count;
    if (stat._id === "carousel") result.carousels = stat.count;
  });

  return result;
};

export default mongoose.models.LinkedInContent || mongoose.model("LinkedInContent", LinkedInContentSchema);
